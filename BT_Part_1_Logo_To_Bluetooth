#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// ===== OLED DEFINES =====
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_MOSI   23
#define OLED_CLK    18
#define OLED_RESET  22
#define OLED_DC     21
#define OLED_CS     19

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &SPI,
                         OLED_DC, OLED_RESET, OLED_CS);

// After display.setRotation(3):
//   display.width()  = 64
//   display.height() = 128

// One completely blank 64-pixel row for the bitmap
#define BLANK_ROW 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

// ===== R LOGO BITMAP (64 x 128) =====
const unsigned char PROGMEM MY_BITMAP[] = {

  // ---------- Rows 1–35: blank ----------
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,

  // ---------- Rows 36–47 ----------
  0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00,   // 36
  0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00,   // 37
  0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00,   // 38
  0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,   // 39
  0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00,   // 40
  0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00,   // 41
  0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00,   // 42
  0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00,   // 43
  0x00, 0x03, 0xFC, 0x00, 0xFF, 0xFF, 0xF8, 0x00,   // 44
  0x00, 0x03, 0xE0, 0x00, 0x1F, 0xFF, 0xF8, 0x00,   // 45
  0x00, 0x03, 0x00, 0x00, 0x07, 0xFF, 0xFC, 0x00,   // 46
  0x00, 0x02, 0x00, 0x00, 0x01, 0xFF, 0xFC, 0x00,   // 47

  // ---------- Rows 48–57 ----------
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFC, 0x00,   // 48
  0x00, 0x00, 0x00, 0x00, 0xE0, 0x1F, 0xFE, 0x00,   // 49
  0x00, 0x00, 0x00, 0x00, 0xE0, 0x0F, 0xFE, 0x00,   // 50
  0x00, 0x00, 0x00, 0x00, 0xE0, 0x0F, 0xFE, 0x00,   // 51
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFC, 0x00,   // 52
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFC, 0x00,   // 53
  0x00, 0x02, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0x00,   // 54
  0x00, 0x03, 0x00, 0x00, 0x03, 0xFF, 0xFC, 0x00,   // 55
  0x00, 0x03, 0xE0, 0x00, 0x0F, 0xFF, 0xF8, 0x00,   // 56
  0x00, 0x03, 0xFC, 0x00, 0x7F, 0xFF, 0xF8, 0x00,   // 57

  // ---------- Rows 58–67 ----------
  0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00,   // 58
  0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00,   // 59
  0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xE0, 0x00,   // 60
  0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xE0, 0x00,   // 61
  0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00,   // 62
  0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,   // 63
  0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,   // 64
  0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFC, 0x00, 0x00,   // 65
  0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF8, 0x00, 0x00,   // 66
  0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFC, 0x00, 0x00,   // 67

  // ---------- Rows 68–77 ----------
  0x00, 0x03, 0xFF, 0xE0, 0xFF, 0xFE, 0x00, 0x00,   // 68
  0x00, 0x03, 0xFF, 0xE0, 0x7F, 0xFF, 0x00, 0x00,   // 69
  0x00, 0x03, 0xFF, 0xE0, 0x3F, 0xFF, 0x00, 0x00,   // 70
  0x00, 0x00, 0x3F, 0xE0, 0x1F, 0xFF, 0x80, 0x00,   // 71
  0x00, 0x00, 0x3F, 0xE0, 0x0F, 0xFF, 0xC0, 0x00,   // 72
  0x00, 0x00, 0x3F, 0xE0, 0x0F, 0xFF, 0xC0, 0x00,   // 73
  0x00, 0x03, 0xFF, 0xE0, 0x07, 0xFF, 0xE0, 0x00,   // 74
  0x00, 0x03, 0xFF, 0xE0, 0x03, 0xFF, 0xF0, 0x00,   // 75
  0x00, 0x03, 0xFF, 0xE0, 0x03, 0xFF, 0xF0, 0x00,   // 76
  0x00, 0x03, 0xFF, 0xE0, 0x01, 0xFF, 0xF8, 0x00,   // 77

  // ---------- Rows 78–81 ----------
  0x00, 0x03, 0xFF, 0xE0, 0x00, 0xFF, 0xFC, 0x00,   // 78
  0x00, 0x01, 0xFF, 0xC0, 0x00, 0xFF, 0xFC, 0x00,   // 79
  0x00, 0x00, 0xFF, 0x80, 0x00, 0x7F, 0xFE, 0x00,   // 80
  0x00, 0x00, 0x7F, 0x00, 0x00, 0x7F, 0xFF, 0x00,   // 81

  // ---------- Rows 82–128: blank ----------
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW, BLANK_ROW,
  BLANK_ROW, BLANK_ROW
};

// ===== BLE (ESP32) =====
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>

// Nordic UART-style UUIDs (you can change these to match your app)
static BLEUUID SERVICE_UUID("6E400001-B5A3-F393-E0A9-E50E24DCCA9E");
static BLEUUID CHARACTERISTIC_UUID_RX("6E400002-B5A3-F393-E0A9-E50E24DCCA9E");
static BLEUUID CHARACTERISTIC_UUID_TX("6E400003-B5A3-F393-E0A9-E50E24DCCA9E");

BLEServer* pServer = nullptr;
BLECharacteristic* pTxCharacteristic = nullptr;
bool deviceConnected = false;
bool oldDeviceConnected = false;

class MyServerCallbacks : public BLEServerCallbacks {
  void onConnect(BLEServer* pServer) override {
    deviceConnected = true;
  }
  void onDisconnect(BLEServer* pServer) override {
    deviceConnected = false;
    // Restart advertising so the app can reconnect if needed
    pServer->getAdvertising()->start();
  }
};

// ===== INTRO STATE MACHINE =====
enum IntroState {
  INTRO_LOGO,
  INTRO_BLE_WAIT,
  INTRO_BLE_SUCCESS,
  INTRO_DONE
};

IntroState introState = INTRO_LOGO;

// Timers
unsigned long stateStartMillis = 0;

// Animation timing for "Waiting for bluetooth"
unsigned long lastUpdate = 0;
const unsigned long frameInterval = 300; // ms between frames
int frame = 0; // 0..5 number of dots

// ====== DRAW HELPERS ======

// Helper that draws the AquaSpec intro *without* calling display.display()
// so we can use it inside animations.
void renderIntroScreenNoDisplay() {
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(2);
  display.setCursor(10, 0);  // a little left padding
  display.println("");
  display.println("Aqua");
  display.println(" Spec");

  display.setTextSize(1);
  display.println("");
  display.println("");
  display.println("");
  display.println("");
  display.println("");
  display.println(" by Rotala");
}

void drawIntroLogo() {
  display.clearDisplay();
  renderIntroScreenNoDisplay();
  display.display();
}

void drawBleWaiting(int frameDots) {
  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);

  // Big title, same style
  display.setTextSize(2);
  display.setCursor(10, 0);
  display.println("");
  display.println("Aqua");
  display.println(" Spec");

  // Small text
  display.setTextSize(1);
  display.println("");
  display.println("");
  display.println("");
  display.println("");

  display.println("  Waiting ");
  display.println("    for ");
  display.print(" bluetooth");

  // animated dots on same line
  for (int i = 0; i < frameDots; i++) {
    display.print(". ");
  }

  display.display();
}

void drawBleSuccess() {
  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);

  // Big "Aqua / Spec"
  display.setTextSize(2);
  display.setCursor(10, 0);  // a little left padding
  display.println("");
  display.println("Aqua");
  display.println(" Spec");

  // Small success text
  display.setTextSize(1);
  display.println("");
  display.println("");
  display.println("");
  display.println("");
  display.println("");
  display.println(" Bluetooth");
  display.println(" Connected");

  display.display();
}

// ===== BLE INIT =====
void initBLE() {
  BLEDevice::init("AquaSpec");  // device name that shows in scans
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());

  BLEService* pService = pServer->createService(SERVICE_UUID);

  // TX (notify to app)
  pTxCharacteristic = pService->createCharacteristic(
                         CHARACTERISTIC_UUID_TX,
                         BLECharacteristic::PROPERTY_NOTIFY
                       );
  pTxCharacteristic->addDescriptor(new BLE2902());

  // RX (write from app)
  BLECharacteristic* pRxCharacteristic = pService->createCharacteristic(
                                           CHARACTERISTIC_UUID_RX,
                                           BLECharacteristic::PROPERTY_WRITE
                                         );

  pService->start();

  BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(SERVICE_UUID);
  pAdvertising->setScanResponse(true);
  pAdvertising->setMinPreferred(0x06);  // some recommended defaults
  pAdvertising->setMinPreferred(0x12);
  pAdvertising->start();

  Serial.println("BLE advertising as AquaSpec...");
}

// ===== BOOT LOGO + WIPE SEQUENCE =====

void renderBootLogo() {
  display.clearDisplay();
  // Bitmap is 64x128 after rotation
  display.drawBitmap(0, 0, MY_BITMAP, 64, 128, SSD1306_WHITE);
  display.display();
}

void runBootLogoSequence() {
  int w = display.width();   // 64
  int h = display.height();  // 128

  // 1) Show R logo for 5 seconds
  renderBootLogo();
  delay(3000);

  // 2) Phase 1: wipe over logo (right -> left) to solid white
  for (int x = w; x >= 0; x -= 2) {
    display.clearDisplay();
    display.drawBitmap(0, 0, MY_BITMAP, 64, 128, SSD1306_WHITE);
    // White bar from x to right edge
    display.fillRect(x, 0, w - x, h, SSD1306_WHITE);
    display.display();
    delay(15);
  }

  // 3) Phase 2: reveal AquaSpec intro (right -> left)
  for (int x = w; x >= 0; x -= 2) {
    display.clearDisplay();
    renderIntroScreenNoDisplay();              // draw full intro in buffer
    display.fillRect(0, 0, x, h, SSD1306_WHITE); // keep left side white
    display.display();
    delay(15);
  }

  // 4) Ensure final frame is clean intro screen
  drawIntroLogo();
}

// ===== SETUP =====
void setup() {
  Serial.begin(115200);

  // OLED init
  SPI.begin(OLED_CLK, -1, OLED_MOSI, OLED_CS);
  if (!display.begin(SSD1306_SWITCHCAPVCC)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;) {}
  }
  display.setRotation(3);

  // Start BLE so it's advertising during the boot logo as well
  initBLE();

  // Run R-logo + wipe into AquaSpec intro
  runBootLogoSequence();

  // Now we're sitting on the AquaSpec intro screen.
  // Let the existing intro state machine take over from here.
  introState = INTRO_LOGO;
  stateStartMillis = millis();
}

// ===== LOOP =====
void loop() {
  unsigned long now = millis();

  switch (introState) {

    case INTRO_LOGO:
      // Stay on "Aquaspec by Rotala" for 2 seconds
      if (now - stateStartMillis >= 3000) {
        introState = INTRO_BLE_WAIT;
        stateStartMillis = now;
        frame = 0;
        lastUpdate = now;
        drawBleWaiting(frame);
      }
      break;

    case INTRO_BLE_WAIT:
      // Animate "Waiting for bluetooth" while advertising BLE
      if (now - lastUpdate >= frameInterval) {
        lastUpdate = now;
        frame = (frame + 1) % 6;  // 0..5
        drawBleWaiting(frame);
      }

      // If BLE connects, go to success screen
      if (deviceConnected && !oldDeviceConnected) {
        oldDeviceConnected = deviceConnected;
        introState = INTRO_BLE_SUCCESS;
        stateStartMillis = now;
        drawBleSuccess();
      }
      break;

    case INTRO_BLE_SUCCESS:
      // Show success screen for 3 seconds
      if (now - stateStartMillis >= 3000) {
        introState = INTRO_DONE;
        // For now, just leave the success screen up.
        // Later we can transition into main UI here.
      }
      break;

    case INTRO_DONE:
      // Do nothing for now – stays on Bluetooth Connected screen
      break;
  }

  // Track disconnects (in case you care later)
  if (!deviceConnected && oldDeviceConnected) {
    oldDeviceConnected = deviceConnected;
    // Optionally: jump back to INTRO_BLE_WAIT here if you want
    // introState = INTRO_BLE_WAIT;
    // stateStartMillis = millis();
  }
}
